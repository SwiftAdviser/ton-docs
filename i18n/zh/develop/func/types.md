# 類型
FunC 具有以下內置類型。

## 原子類型
- `int` 是 257 位有符號整數的類型。默認情況下，啟用溢出檢查並導致整數溢出異常。
- `cell` 是 TVM 單元格的類型。TON 區塊鏈中的所有持久數據都存儲在 cell 樹中。每個 cell 最多具有 1023 個任意數據位和最多四個對其他 cell 的引用。cell 在基於堆棧的 TVM 中用作內存。
- `slice` 是單元格切片的類型。可以將 cell 轉換為 slice，然後可以通過從 slice 中加載它們來獲取 cell 的數據位和對其他 cell 的引用。
- `builder` 是 cell 構建器的類型。數據位和對其他 cell 的引用可以存儲在構建器中，然後可以將構建器最終化為新的 cell。
- `tuple` 是 TVM tuple 的類型。Tuple 是最多具有 255 個任意值類型的有序集合，這些類型可能不同。
- `cont` 是 TVM continuation 的類型。Continuation 用於控制 TVM 程序執行的流程。從 FunC 的角度來看，這是一個相當低級的對象，雖然矛盾地相當通用。

請注意，上述任何類型都只佔用 TVM 堆棧中的一個條目。

### 沒有布林類型
在 FunC 中，布林值用整數表示；`false` 表示為 `0`，而 `true` 則表示為 `-1`（在二進制表示法中為 257 個 1）。邏輯運算是通過位運算來實現的。當檢查條件時，每個非零整數都被認為是一個 `true` 值。


### 空值
FunC 通過 TVM 類型 `Null` 的值 `null` 來表示某個原子類型的值的缺失。標准庫中的一些原始操作可能被定義為返回一個原子類型的值，實際上在某些情況下返回 `null`。其他操作可能被定義為期望一個原子類型的值，但在處理 `null` 值時也可以正常工作。這種行為在原始操作的規範中明確說明。默認情況下，`null` 值是被禁止的，會導致運行時異常。

這樣，原子類型 `A` 可能會被隱式轉換為類型 `A^?`，也就是 `Maybe A`（類型檢查器對此類轉換是不加區分的）。


## 空類型
FunC 支持類型推斷。類型 `_` 和 `var` 表示可以在類型檢查期間稍後填充某些實際類型的類型“洞”。例如，`var x = 2;` 是一個等於 `2` 的變量 `x` 的定義。類型檢查器可以推斷出 `x` 具有類型 `int`，因為 `2` 具有類型 `int`，且賦值的左邊和右邊必須具有相等的類型。

## 複合類型
類型可以組合成更複雜的類型。


### 函数类型
形如 `A -> B` 的类型表示具有指定定义域和值域的函数。例如，`int -> cell` 是一种函数类型，它接受一个整数参数并返回一个 TVM cell。

在内部，这种类型的值是以 continuation 的形式表示的。


### 張量類型
形式為 `(A, B, ...)` 的類型實質上表示類型 `A`、`B`、... 的有序值集合，這些值總共佔用多個 TVM 堆棧條目。

例如，如果一個函數 `foo` 具有類型 `int -> (int, int)`，則意味著該函數接受一個整數並返回一對整數。

調用此函數的示例可能類似於 `(int a, int b) = foo(42);`。在內部，該函數消耗一個堆棧條目並留下兩個條目。


注意，從低層次的角度來看，類型為 `(int, (int, int))` 的值 `(2, (3, 9))` 和類型為 `(int, int, int)` 的值 `(2, 3, 9)` 在同一個層級上表示為三個堆棧條目 `2`、`3` 和 `9`。對於 FunC 類型檢查器來說，它們是**不同**類型的值。例如，代碼 `(int a, int b, int c) = (2, (3, 9));` 不會被編譯。

張量類型的一個特殊情況是 **unit 類型** `()`。它通常用於表示函數沒有返回值或沒有參數。例如，函數 `print_int` 具有類型 `int -> ()`，而函數 `random` 具有類型 `() -> int`。它有一個唯一的成員 `()`，佔用 0 堆棧條目。

形式為 `(A)` 的類型被認為是與 `A` 相同的類型。

### 元組類型
形如 `[A, B, ...]` 的類型表示具有特定組件長度和在編譯時已知的組件類型的 TVM 元組。例如，`[int, cell]` 是長度正好為 2 的 TVM 元組的類型，其中第一個組件是整數，第二個組件是 cell。`[]` 是空元組的類型（具有唯一的實例 - 空元組）。請注意，與單元類型 `()` 不同，`[]` 的值佔用一個堆棧條目。


## 通過類型變量實現多態性
FunC 具有支持多態函數的 Miller-Rabin 類型系統。例如，以下函數：

```func
forall X -> (X, X) duplicate(X value) {
  return (value, value);
}
```
是一個多態函數，它接受一個（單個堆棧條目）值並返回這個值的兩個副本。`duplicate(6)` 將生成值 `6 6`，而 `duplicate([])` 將生成兩個空元組 `[] []` 的副本。

在這個例子中，`X` 是一個類型變量。

在 [函數](/develop/func/functions#polymorphism-with-forall) 部分中查看更多有關此主題的信息。

## 用戶定義類型
目前，除了上述類型構造之外，FunC 不支持定義類型。


## 類型寬度
您可能已經注意到，每種類型的每個值都佔用一定數量的堆棧條目。如果所有該類型的值都具有相同的條目數，則稱為**類型寬度**。目前，只能為具有固定且預先已知類型寬度的類型定義多態函數。
